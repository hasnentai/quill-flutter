<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quill Editor Test - Table Support</title>
    
    <!-- Quill.js CSS -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css" rel="stylesheet">

    
    <!-- Quill Better Table CSS -->
    <link href="https://cdn.jsdelivr.net/npm/quill-table-better@1/dist/quill-table-better.css" rel="stylesheet">

   

    
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0px;
            background-color: transparent;
        }
       
        .ql-container.ql-snow{
          height: 400px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2em;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }
        
        .toolbar-custom {
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn.secondary {
            background: #6c757d;
        }
        
        .btn.secondary:hover {
            background: #545b62;
        }
        
        .btn.success {
            background: #28a745;
        }
        
        .btn.success:hover {
            background: #1e7e34;
        }
        
        .editor-container {
            padding: 20px;
            min-height: 400px;
        }
        
        .content-preview {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        
        .content-preview h3 {
            margin-top: 0;
            color: #495057;
        }
        
        .content-preview pre {
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 14px;
            color: #6c757d;
        }
        
        .feature-list {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .feature-list h4 {
            margin-top: 0;
            color: #1976d2;
        }
        
        .feature-list ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .feature-list li {
            margin: 5px 0;
        }
        
        .table-demo {
            background: #fff3cd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .table-demo h4 {
            margin-top: 0;
            color: #856404;
        }
        
        /* Format Painter button styling */
        .ql-format-painter {
            position: relative;
        }
        
        .ql-format-painter.ql-active {
            background-color: #e3f2fd !important;
        }
        
        .ql-format-painter.ql-active::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(33, 150, 243, 0.2);
            border-radius: 2px;
            pointer-events: none;
        }
        
        /* Format Painter icon (paintbrush SVG) */
        .ql-format-painter svg {
            display: inline-block;
            vertical-align: middle;
            width: 18px;
            height: 18px;
        }
        
        .ql-format-painter::before {
            content: '';
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <br/>
 
    

    <script src="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quill-table-better@1/dist/quill-table-better.js"></script>

    <script>
        Quill.register({
  'modules/table-better': QuillTableBetter
}, true);

// Format Painter custom handler
const FormatPainter = {
  storedFormat: null,
  isActive: false,
  
  copyFormat() {
    const selection = editor.getSelection(true);
    if (!selection) {
      return false;
    }
    
    // Get the format at the selection
    const format = editor.getFormat(selection);
    
    // Store the format (filter out attributes we don't want to copy)
    this.storedFormat = {};
    const attributesToCopy = [
      'bold', 'italic', 'underline', 'strike',
      'color', 'background',
      'font', 'size',
      'script', 'link',
      'header', 'align',
      'blockquote', 'code-block',
      'list', 'indent', 'direction'
    ];
    
    attributesToCopy.forEach(attr => {
      if (format[attr] !== undefined && format[attr] !== null && format[attr] !== '') {
        this.storedFormat[attr] = format[attr];
      }
    });
    
    // If we have any format to copy, activate
    if (Object.keys(this.storedFormat).length > 0) {
      this.isActive = true;
      this.updateButtonState();
      return true;
    }
    
    return false;
  },
  
  applyFormat() {
    if (!this.storedFormat || !this.isActive) {
      return false;
    }
    
    const selection = editor.getSelection(true);
    if (!selection || selection.length === 0) {
      return false;
    }
    
    // Apply the stored format to the current selection
    Object.keys(this.storedFormat).forEach(attr => {
      const value = this.storedFormat[attr];
      editor.formatText(selection.index, selection.length, attr, value, Quill.sources.USER);
    });
    
    // Deactivate after applying (single-use mode)
    this.isActive = false;
    this.updateButtonState();
    return true;
  },
  
  updateButtonState() {
    setTimeout(() => {
      const button = document.querySelector('.ql-format-painter');
      if (button) {
        if (this.isActive) {
          button.classList.add('ql-active');
          button.title = 'Format Painter Active - Select text and click to apply format';
        } else {
          button.classList.remove('ql-active');
          button.title = 'Format Painter - Select formatted text and click to copy format';
        }
      }
    }, 50);
  },
  
  handleClick() {
    const selection = editor.getSelection(true);
    
    if (this.isActive) {
      // Format painter is active - apply format to current selection
      if (selection && selection.length > 0) {
        this.applyFormat();
      } else {
        // No selection, deactivate
        this.isActive = false;
        this.updateButtonState();
      }
    } else {
      // Format painter is not active - copy format from current selection
      if (selection && selection.length > 0) {
        this.copyFormat();
      } else if (selection) {
        // No text selected, try to get format at cursor position
        const format = editor.getFormat(selection);
        if (Object.keys(format).length > 0) {
          this.storedFormat = {};
          const attributesToCopy = [
            'bold', 'italic', 'underline', 'strike',
            'color', 'background', 'font', 'size',
            'script', 'link', 'header', 'align',
            'blockquote', 'code-block', 'list', 'indent', 'direction'
          ];
          attributesToCopy.forEach(attr => {
            if (format[attr] !== undefined && format[attr] !== null && format[attr] !== '') {
              this.storedFormat[attr] = format[attr];
            }
          });
          if (Object.keys(this.storedFormat).length > 0) {
            this.isActive = true;
            this.updateButtonState();
          }
        }
      }
    }
  }
};

const toolbarOptions = [
  ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
  ['format-painter'],                                // format painter button
  ['blockquote', 'code-block'],
  ['link', 'image', 'video', 'formula'],

  [{ 'header': 1 }, { 'header': 2 }],               // custom button values
  [{ 'list': 'ordered'}, { 'list': 'bullet' }, { 'list': 'check' }],
  [{ 'script': 'sub'}, { 'script': 'super' }],      // superscript/subscript
  [{ 'indent': '-1'}, { 'indent': '+1' }],          // outdent/indent
  [{ 'direction': 'rtl' }],                         // text direction

  [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
  [{ 'header': [1, 2, 3, 4, 5, 6, false] }],

  [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme
  [{ 'font': [] }],
  [{ 'align': [] }],

  ['clean'],                                        // remove formatting button
  ['table-better']
];

const options = {
  theme: 'snow',
  modules: {
    toolbar: {
      container: toolbarOptions,
      handlers: {
        'format-painter': function() {
          FormatPainter.handleClick();
        }
      }
    },
    table: false,
    'table-better': {
      toolbarTable: true,
      menus: ['column', 'row', 'merge', 'table', 'cell', 'wrap', 'copy', 'delete'],
    },
    keyboard: {
      bindings: QuillTableBetter.keyboardBindings
    }
  }
};

const editor = new Quill('#root', options);

// Add tooltips to all toolbar items
function addTooltipsToToolbar() {
  const toolbar = editor.getModule('toolbar');
  const toolbarElement = toolbar.container;
  
  // Function to add tooltip to an element
  function setTooltip(element, text) {
    if (element && !element.title) {
      element.title = text;
    }
  }
  
  // Add tooltips after a short delay to ensure DOM is ready
  setTimeout(() => {
    // Simple buttons with direct tooltips
    const buttonTooltips = {
      'ql-bold': 'Bold (Ctrl+B)',
      'ql-italic': 'Italic (Ctrl+I)',
      'ql-underline': 'Underline (Ctrl+U)',
      'ql-strike': 'Strikethrough',
      'ql-format-painter': 'Format Painter',
      'ql-blockquote': 'Blockquote',
      'ql-code-block': 'Code Block',
      'ql-link': 'Insert Link',
      'ql-image': 'Insert Image',
      'ql-video': 'Insert Video',
      'ql-formula': 'Insert Formula',
      'ql-clean': 'Remove Formatting',
      'ql-table-better': 'Insert Table'
    };
    
    // Add tooltips to simple buttons
    Object.keys(buttonTooltips).forEach(className => {
      toolbarElement.querySelectorAll(`button.${className}`).forEach(button => {
        setTooltip(button, buttonTooltips[className]);
      });
    });
    
    // Header buttons
    toolbarElement.querySelectorAll('button.ql-header').forEach(button => {
      const value = button.getAttribute('value');
      if (value === '1') setTooltip(button, 'Heading 1');
      else if (value === '2') setTooltip(button, 'Heading 2');
      else setTooltip(button, 'Heading');
    });
    
    // List buttons
    toolbarElement.querySelectorAll('button.ql-list').forEach(button => {
      const value = button.getAttribute('value');
      if (value === 'ordered') setTooltip(button, 'Numbered List');
      else if (value === 'bullet') setTooltip(button, 'Bullet List');
      else if (value === 'check') setTooltip(button, 'Check List');
      else setTooltip(button, 'List');
    });
    
    // Script buttons (subscript/superscript)
    toolbarElement.querySelectorAll('button.ql-script').forEach(button => {
      const value = button.getAttribute('value');
      if (value === 'sub') setTooltip(button, 'Subscript');
      else if (value === 'super') setTooltip(button, 'Superscript');
    });
    
    // Indent buttons
    toolbarElement.querySelectorAll('button.ql-indent').forEach(button => {
      const value = button.getAttribute('value');
      if (value === '-1') setTooltip(button, 'Decrease Indent');
      else if (value === '+1') setTooltip(button, 'Increase Indent');
    });
    
    // Direction button
    toolbarElement.querySelectorAll('button.ql-direction').forEach(button => {
      if (button.getAttribute('value') === 'rtl') {
        setTooltip(button, 'Right to Left');
      }
    });
    
    // Dropdown pickers (size, header, color, background, font, align)
    const pickerTooltips = {
      'ql-size': 'Text Size',
      'ql-header': 'Heading',
      'ql-color': 'Text Color',
      'ql-background': 'Background Color',
      'ql-font': 'Font Family',
      'ql-align': 'Text Alignment'
    };
    
    Object.keys(pickerTooltips).forEach(pickerClass => {
      const picker = toolbarElement.querySelector(`.ql-picker.${pickerClass}`);
      if (picker) {
        const label = picker.querySelector('.ql-picker-label');
        if (label) setTooltip(label, pickerTooltips[pickerClass]);
      }
    });
    
    // Fallback: add tooltips to any remaining buttons
    toolbarElement.querySelectorAll('button').forEach(button => {
      if (!button.title) {
        const classes = Array.from(button.classList);
        const qlClass = classes.find(cls => cls.startsWith('ql-') && cls !== 'ql-picker-label');
        if (qlClass && buttonTooltips[qlClass]) {
          setTooltip(button, buttonTooltips[qlClass]);
        }
      }
    });
  }, 100);
}

// Initialize tooltips after editor is ready
addTooltipsToToolbar();

// Add format painter icon after toolbar is created
setTimeout(() => {
  const formatPainterButton = document.querySelector('.ql-format-painter');
  if (formatPainterButton && !formatPainterButton.querySelector('svg')) {
    // Add paintbrush SVG icon
    formatPainterButton.innerHTML = `
      <svg viewBox="0 0 18 18">
        <path d="M13.5 2.5L15.5 4.5L6.5 13.5L4.5 11.5L13.5 2.5Z" fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M3.5 15.5L4.5 14.5L5.5 15.5L4.5 16.5L3.5 15.5Z" fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M2.5 12.5L3.5 13.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    `;
  }
}, 150);

let delta = null;
let html = '';
let messageId = 0;
let lastMessageTime = 0;
const MESSAGE_THROTTLE = 100; // milliseconds

// Function to send message to Flutter
function sendMessageToFlutter(message) {
  
  if (window.parent) {
    window.parent.postMessage(message, '*');
  }
}

// Function to send JSON data to Flutter
function sendJsonToFlutter(data) {
  // Throttle messages to prevent spam

  const now = Date.now();
  if (now - lastMessageTime < MESSAGE_THROTTLE) {
    return;
  }
  lastMessageTime = now;
  
  // Add unique ID to prevent loops
  data.messageId = ++messageId;
  data.source = 'iframe';
  sendMessageToFlutter(JSON.stringify(data));
}

// Listen for messages from Flutter
window.addEventListener('message', function(event) {
  // Only process messages from the parent window (Flutter)
  if (event.source !== window.parent) {
    return;
  }
  
  try {
    const data = JSON.parse(event.data);
    // Only handle command messages, not response messages
    if (data.type === 'command') {
      handleFlutterCommand(data);
    }
  } catch (e) {
    // Handle plain string messages
    
    sendMessageToFlutter('Echo: ' + event.data);
  }
});

// Handle commands from Flutter
function handleFlutterCommand(data) {
 
  
  // Prevent processing the same command multiple times
  if (data._processed) {
    return;
  }
  data._processed = true;
  
  switch (data.action) {
    case 'insertTable':
      const rows = data.rows || 3;
      const cols = data.cols || 3;
      tableModule.insertTable(rows, cols);
      sendJsonToFlutter({
        type: 'response',
        action: 'insertTable',
        success: true,
        message: `Table inserted: ${rows}x${cols}`,
        timestamp: Date.now()
      });
      break;
      
    case 'getContents':
      const content = editor.getContents();
      const htmlContent = editor.getSemanticHTML();
      sendJsonToFlutter({
        type: 'response',
        action: 'getContents',
        success: true,
        data: {
          delta: content,
          html: htmlContent,
          text: editor.getText()
        },
        timestamp: Date.now()
      });
      break;
      
    case 'setContents':
      if (data.delta) {
        editor.setContents(data.delta, Quill.sources.USER);
        sendJsonToFlutter({
          type: 'response',
          action: 'setContents',
          success: true,
          message: 'Contents set successfully',
          timestamp: Date.now()
        });
      }
      break;
      
    default:
      sendJsonToFlutter({
        type: 'response',
        action: data.action || 'unknown',
        success: false,
        message: 'Unknown command',
        timestamp: Date.now()
      });
  }
}

// Send initial message to Flutter when iframe loads
window.addEventListener('load', function() {

});

// Send content change notifications (throttled)
let contentChangeTimeout;
editor.on('text-change', function(delta, oldDelta, source) {
  if (source === 'user') {
    // Send immediate update with complete content
    const completeContent = editor.getContents();
    const htmlContent = editor.getSemanticHTML();
    const textContent = editor.getText();
    
    sendJsonToFlutter({
      type: 'contentChange',
      delta: completeContent, // Send complete content, not just the change
      html: htmlContent,
      text: textContent,
      timestamp: Date.now()
    });
    
    // Also send a throttled summary for heavy operations
    clearTimeout(contentChangeTimeout);
    contentChangeTimeout = setTimeout(() => {
    
    }, 1000); // Wait 1 second after last change
  }
});

// Handle selection changes to apply format when format painter is active
editor.on('selection-change', function(range, oldRange, source) {
  if (FormatPainter.isActive && range && range.length > 0) {
    // Format painter is active and user has selected text
    // The format will be applied when they click the button again
    // Or we can auto-apply on selection change (uncomment below if preferred)
    // FormatPainter.applyFormat();
  } else if (FormatPainter.isActive && (!range || range.length === 0)) {
    // Selection cleared, keep format painter active for next selection
  }
});

  


    </script>

   
</body>
</html>
